const { CodeForgeOrchestrator } = require('./api-flui/dist/core/codeForgeOrchestrator');
const axios = require('axios');

// Mock Pollinations API
const mockPollinationsAPI = {
  async post(url, data) {
    const { messages } = data;
    const lastMessage = messages[messages.length - 1];
    const content = lastMessage.content.toLowerCase();
    
    let response;
    
    if (url.includes('/chat/completions')) {
      if (content.includes('landing page') || content.includes('html')) {
        response = {
          domain: "frontend",
          technology: "html",
          language: "javascript",
          framework: "vanilla",
          purpose: "landing page",
          complexity: "simple",
          features: ["responsive", "modern", "interactive"],
          requirements: ["mobile-friendly", "fast-loading", "seo-optimized"]
        };
      } else if (content.includes('api') || content.includes('backend') || content.includes('node')) {
        response = {
          domain: "backend",
          technology: "nodejs",
          language: "javascript",
          framework: "express",
          purpose: "api server",
          complexity: "medium",
          features: ["rest-api", "authentication", "database"],
          requirements: ["scalable", "secure", "documented"]
        };
      } else {
        response = {
          domain: "unknown",
          technology: "unknown",
          language: "unknown",
          framework: "unknown",
          purpose: "unknown",
          complexity: "simple",
          features: [],
          requirements: []
        };
      }
    }
    
    return {
      data: {
        choices: [{
          message: {
            content: JSON.stringify(response)
          }
        }]
      }
    };
  }
};

// Override axios for mock
axios.post = mockPollinationsAPI.post.bind(mockPollinationsAPI);

async function testCallbacksDetailed() {
  console.log('üìû TESTE DETALHADO DOS CALLBACKS DO FLUI');
  console.log('=' .repeat(80));
  
  const orchestrator = new CodeForgeOrchestrator('/tmp/flui-callback-test');
  
  // Track all callbacks
  const callbackTracker = {
    // CodeForgeOrchestrator callbacks
    'userInputProcessed': 0,
    'userAnswersProcessed': 0,
    'taskCreated': 0,
    'projectCreated': 0,
    'projectCreationFailed': 0,
    'modificationRequestCreated': 0,
    'modificationExecuted': 0,
    'modificationFailed': 0,
    'downloadRequestCreated': 0,
    'downloadExecuted': 0,
    'downloadFailed': 0,
    'interactiveMessageHandled': 0,
    
    // CodeForgeAgent callbacks
    'projectStart': 0,
    'projectComplete': 0,
    'projectError': 0,
    'taskStart': 0,
    'taskComplete': 0,
    'taskError': 0,
    'modificationStart': 0,
    'modificationComplete': 0,
    'modificationError': 0,
    'downloadStart': 0,
    'downloadReady': 0
  };
  
  // Setup callback listeners
  Object.keys(callbackTracker).forEach(eventName => {
    orchestrator.on(eventName, (data) => {
      callbackTracker[eventName]++;
      console.log(`üìû CALLBACK EXECUTADO: ${eventName}`);
      console.log(`   üìä Data:`, JSON.stringify(data, null, 2));
    });
  });
  
  console.log('\nüéØ TESTE 1: PROCESSAMENTO DE INPUT DO USU√ÅRIO');
  console.log('-' .repeat(60));
  
  try {
    const result1 = await orchestrator.processUserInput(
      'Crie uma landing page HTML moderna',
      'user-callback-test'
    );
    console.log(`‚úÖ Resultado 1: ${result1.success ? 'SUCESSO' : 'FALHA'}`);
    console.log(`üìä Confidence: ${result1.confidence}`);
    console.log(`üéØ Intent: ${JSON.stringify(result1.intent)}`);
  } catch (error) {
    console.log(`‚ùå Erro no teste 1: ${error.message}`);
  }
  
  console.log('\nüéØ TESTE 2: CRIA√á√ÉO DE TAREFA PERSISTENTE');
  console.log('-' .repeat(60));
  
  try {
    const result2 = await orchestrator.createPersistentTask(
      'Landing Page HTML',
      'Criar uma landing page moderna',
      'frontend',
      'user-callback-test',
      'Crie uma landing page HTML moderna'
    );
    console.log(`‚úÖ Resultado 2: ${result2.success ? 'SUCESSO' : 'FALHA'}`);
    if (result2.success) {
      console.log(`üìã Task ID: ${result2.taskId}`);
    }
  } catch (error) {
    console.log(`‚ùå Erro no teste 2: ${error.message}`);
  }
  
  console.log('\nüéØ TESTE 3: EXECU√á√ÉO DE TAREFA');
  console.log('-' .repeat(60));
  
  try {
    // First create a task
    const taskResult = await orchestrator.createPersistentTask(
      'Test Task',
      'Test task for callback analysis',
      'frontend',
      'user-callback-test',
      'Test task'
    );
    
    if (taskResult.success) {
      const result3 = await orchestrator.executePersistentTask(taskResult.taskId);
      console.log(`‚úÖ Resultado 3: ${result3.success ? 'SUCESSO' : 'FALHA'}`);
      if (result3.success) {
        console.log(`üìä Report Path: ${result3.reportPath}`);
        console.log(`üåê Live URL: ${result3.liveUrl}`);
      }
    }
  } catch (error) {
    console.log(`‚ùå Erro no teste 3: ${error.message}`);
  }
  
  console.log('\nüéØ TESTE 4: INTERA√á√ÉO COM TAREFA');
  console.log('-' .repeat(60));
  
  try {
    // First create a task
    const taskResult = await orchestrator.createPersistentTask(
      'Interactive Task',
      'Interactive task for callback analysis',
      'frontend',
      'user-callback-test',
      'Interactive task'
    );
    
    if (taskResult.success) {
      const result4 = await orchestrator.interactWithPersistentTask(
        taskResult.taskId,
        'Como est√° o progresso?',
        'user-callback-test'
      );
      console.log(`‚úÖ Resultado 4: ${result4.success ? 'SUCESSO' : 'FALHA'}`);
      if (result4.success) {
        console.log(`üìù Response: ${result4.response}`);
      }
    }
  } catch (error) {
    console.log(`‚ùå Erro no teste 4: ${error.message}`);
  }
  
  console.log('\nüìä RELAT√ìRIO DE CALLBACKS EXECUTADOS:');
  console.log('=' .repeat(80));
  
  const totalCallbacks = Object.values(callbackTracker).reduce((sum, count) => sum + count, 0);
  const executedCallbacks = Object.entries(callbackTracker).filter(([_, count]) => count > 0);
  const notExecutedCallbacks = Object.entries(callbackTracker).filter(([_, count]) => count === 0);
  
  console.log(`üìû Total de Callbacks Executados: ${totalCallbacks}`);
  console.log(`‚úÖ Callbacks Executados: ${executedCallbacks.length}`);
  console.log(`‚ùå Callbacks N√ÉO Executados: ${notExecutedCallbacks.length}`);
  
  console.log('\n‚úÖ CALLBACKS EXECUTADOS:');
  console.log('-' .repeat(40));
  executedCallbacks.forEach(([event, count]) => {
    console.log(`  üìû ${event}: ${count} execu√ß√µes`);
  });
  
  console.log('\n‚ùå CALLBACKS N√ÉO EXECUTADOS:');
  console.log('-' .repeat(40));
  notExecutedCallbacks.forEach(([event, count]) => {
    console.log(`  üìû ${event}: ${count} execu√ß√µes`);
  });
  
  console.log('\nüéØ AN√ÅLISE DOS CALLBACKS:');
  console.log('=' .repeat(80));
  
  console.log('\nüìã CALLBACKS DO CODEFORGEORCHESTRATOR:');
  console.log('-' .repeat(50));
  const orchestratorCallbacks = [
    'userInputProcessed',
    'userAnswersProcessed', 
    'taskCreated',
    'projectCreated',
    'projectCreationFailed',
    'modificationRequestCreated',
    'modificationExecuted',
    'modificationFailed',
    'downloadRequestCreated',
    'downloadExecuted',
    'downloadFailed',
    'interactiveMessageHandled'
  ];
  
  orchestratorCallbacks.forEach(callback => {
    const count = callbackTracker[callback];
    const status = count > 0 ? '‚úÖ' : '‚ùå';
    console.log(`  ${status} ${callback}: ${count} execu√ß√µes`);
  });
  
  console.log('\nüìã CALLBACKS DO CODEFORGEAGENT:');
  console.log('-' .repeat(50));
  const agentCallbacks = [
    'projectStart',
    'projectComplete',
    'projectError',
    'taskStart',
    'taskComplete',
    'taskError',
    'modificationStart',
    'modificationComplete',
    'modificationError',
    'downloadStart',
    'downloadReady'
  ];
  
  agentCallbacks.forEach(callback => {
    const count = callbackTracker[callback];
    const status = count > 0 ? '‚úÖ' : '‚ùå';
    console.log(`  ${status} ${callback}: ${count} execu√ß√µes`);
  });
  
  console.log('\nüîç EXPLICA√á√ÉO DOS CALLBACKS:');
  console.log('=' .repeat(80));
  
  console.log('\nüìû CALLBACKS DO ORCHESTRATOR:');
  console.log('  ‚Ä¢ userInputProcessed: Disparado quando input do usu√°rio √© processado');
  console.log('  ‚Ä¢ userAnswersProcessed: Disparado quando respostas do usu√°rio s√£o processadas');
  console.log('  ‚Ä¢ taskCreated: Disparado quando uma task √© criada');
  console.log('  ‚Ä¢ projectCreated: Disparado quando um projeto √© criado com sucesso');
  console.log('  ‚Ä¢ projectCreationFailed: Disparado quando cria√ß√£o de projeto falha');
  console.log('  ‚Ä¢ modificationRequestCreated: Disparado quando requisi√ß√£o de modifica√ß√£o √© criada');
  console.log('  ‚Ä¢ modificationExecuted: Disparado quando modifica√ß√£o √© executada');
  console.log('  ‚Ä¢ modificationFailed: Disparado quando modifica√ß√£o falha');
  console.log('  ‚Ä¢ downloadRequestCreated: Disparado quando requisi√ß√£o de download √© criada');
  console.log('  ‚Ä¢ downloadExecuted: Disparado quando download √© executado');
  console.log('  ‚Ä¢ downloadFailed: Disparado quando download falha');
  console.log('  ‚Ä¢ interactiveMessageHandled: Disparado quando mensagem interativa √© processada');
  
  console.log('\nüìû CALLBACKS DO AGENT:');
  console.log('  ‚Ä¢ projectStart: Disparado quando projeto inicia');
  console.log('  ‚Ä¢ projectComplete: Disparado quando projeto √© completado');
  console.log('  ‚Ä¢ projectError: Disparado quando projeto tem erro');
  console.log('  ‚Ä¢ taskStart: Disparado quando task inicia');
  console.log('  ‚Ä¢ taskComplete: Disparado quando task √© completada');
  console.log('  ‚Ä¢ taskError: Disparado quando task tem erro');
  console.log('  ‚Ä¢ modificationStart: Disparado quando modifica√ß√£o inicia');
  console.log('  ‚Ä¢ modificationComplete: Disparado quando modifica√ß√£o √© completada');
  console.log('  ‚Ä¢ modificationError: Disparado quando modifica√ß√£o tem erro');
  console.log('  ‚Ä¢ downloadStart: Disparado quando download inicia');
  console.log('  ‚Ä¢ downloadReady: Disparado quando download est√° pronto');
  
  console.log('\nüèÜ RESULTADO FINAL:');
  console.log('=' .repeat(80));
  
  if (totalCallbacks > 0) {
    console.log(`üéâ ${totalCallbacks} callbacks foram executados com sucesso!`);
    console.log(`‚úÖ Sistema de callbacks est√° funcionando corretamente`);
  } else {
    console.log(`‚ö†Ô∏è  Nenhum callback foi executado`);
    console.log(`‚ùå Poss√≠vel problema no sistema de eventos`);
  }
  
  console.log('\nüèÅ TESTE DE CALLBACKS CONCLU√çDO!');
}

// Run the callback test
testCallbacksDetailed().catch(error => {
  console.error('‚ùå Erro durante o teste de callbacks:', error);
  process.exit(1);
});